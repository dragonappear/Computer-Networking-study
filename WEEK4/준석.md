# 컴퓨터 네트워크 보안

## 2. 암호의 원리

### 2.1 대칭키 암호화

- 카이사르 암호 : 문자별로 n번만큼 뒤로 이동시킨 문자로 변환하는 방식
- 단일 문자 대응 암호 : 문자를 일정한 규칙에 따라 변환하는 대신 변환 테이블을 사용
- 다중 문자 대응 암호화 : 문자의 종류 뿐만 아니라 문자의 위치에 따라서도 변환값이 달라지게 하는 암호화 방식

#### 블록 암호화

블록암호화 에서는 메시지가 k비트의 블록 단위로 암호화된다. 메세지를 k비트로 나누어 k비트를 변환하는 테이블을 만들어 사용할 수 있는데, 이는 k값이 조금만 늘어나도 엄청난 양의 테이블이 필요하게 되므로 실질적으로 이용이 어렵다.

대신, 블록 암호화 기법은 입출력 블록의 순열 테이블을 임의로 모방 생성하는 함수를 사용한다.

![](https://i.ibb.co/Km0g3pH/temp.png)

k=64이면 64비트 블록을 8비트씩 8개의 청크로 나누고, 각 8비트 청크는 8비트 입력 블록에 대응하는 8비트 출력 블록을 가진 테이블에 의해 처리된다. 이렇게 처리된 청크는 64비트 블록으로 다시 합쳐지고 블록 내 64비트 각각의 위치는 뒤섞여 하나의 64비트 출력을 만들어낸다. 이 사이클을 n번 반복해 최종적인 64비트 암호문 블록이 생성된다.

오늘날 널리 사용되는 암호화 방법에는 DES(Data Encryption Standard), 3DES, AES(Advanced Encryption Standard) 등이 있다.

#### 암호 블록 체이닝

암호화 방식이 같은 평문에 같은 암호문 블록을 생성해낸다면 공격자가 이를 토대로 원문을 추측해낼 수 있는 가능성이 존재한다. 따라서 임의성을 추가해 평문이 동일하더라도 다른 암호문 블록이 생성될 수 있게 해야한다. 이를 위해 암호문 블록과 XOR 연산을 해 다른 비트를 만들어내는 수 r로 변환한다음 그 수를 같이 보냄으로써 해결이 가능하다. 하지만 이 방식도 대역폭이 증가해야 하므로 암호 블록 체이닝이라는 기법을 이용한다.

1. 메시지를 암호화하기 전에 송신자는 초기화 벡터라 불리는 임의의 k비트열을 생성한다. 이 초기화 벡터를 c라 하자. 송신자는 이 초기화 벡터를 평문 형태로 수신자에게 보낸다.

2. 첫 번째 블록에 대해서 송신자는 m XOR c를 계산한다. 즉, 평문의 첫 번째 블록과 IV의 배타적 논리합을 구하는 것이다. 그런 다음, 그 결과를 블록 암호화 알고리즘의 입력으로 사용하여 해당하는 암호문 블록을 얻는다.

3. i번째 블록에 대해 송신자는 c를 이용하여 i번째 암호문 블록을 생성한다.

### 2.2 공개키 암호화

키 하나로 암호화와 복호화를 하는 방식은 키를 상대방에게 안전하게 전달해야 한다는 점에서 불리하다. 이에 공개키와 개인키 2개의 키로 암호화와 복호화를 하는 방식이 존재한다. 알려져 있는 공개키로 암호화를 하면 개인키로만 복호화가 가능하고 개인키로 암호화를 하면 공개키로만 복호화가 가능한 방식이다.

#### RSA

소수를 이용해 암호화하는 방식

#### 세션키

RSA에 필요한 지수 연산은 시간이 많이 필요하므로 암호화에 사용할 세션키(대칭키)를 공개키로 암호화해 전달하는 방식을 자주 사용한다.

## 6. TCP 연결의 보안: TLS

암호학의 기밀성, 데이터 무결성, 종단점 인증 등의 보안 서비스를 이용하여 향상된 TCP를 TLS(Transport Layer Security)라고 부르며, SSL에서 업그레이드 된 버전이다.

TLS는 기밀성, 데이터 무결성, 서버 인증과 클라이언트 인증을 통해 TCP를 향상함으로써 이러한 문제를 해결한다.
![](https://i.ibb.co/HC5xvj2/temp.png)

TLS는 소켓을 사용하는 간단한 API를 제공하는데, 이는 TCP의 API와 유사하다. TLS를 사용하기를 원할 떄 애플리케이션은 SSL 클래스/라이브러리를 포함한다. 그림에 나와있듯이 TLS는 애플리케이션 계층에 존재하나 개발자의 관점에서는 보안 서비스로 강화된 TCP 서비스를 제공하는 트랜스포트 프로토콜이다.

### 6.1 TLS 개요

![](https://i.ibb.co/n0xn52D/temp.png)

#### 핸드셰이크

3-way handshake를 통해 TCP 연결을 설립하고, b과정을 통해 진짜 앨리스 인지 확인하며 c과정을 통해 TLS 세션에 필요한 모든 대칭키를 생성하기 위해 앨리스와 밥이 사용할 주 비밀키를 앨리스에게 전송한다.

TCP연결이 설립되면 밥은 앨리스에세 메세지를 보내고 앨리스는 그녀의 공개키를 담은 인증서로 응답한다. 인증서는 CA에 의해 인증받기 때문에 밥은 인증서 내의 공개키가 앨리스의 것이라는 사실을 확실히 믿을 수 있다. 그다음 밥은 MS를 생성하고, 이를 앨리스의 공개키로 암호화하여 EMS를 만든다. 이 EMS가 앨리스에게 전송되고 앨리스는 자신의 개인키를 가지고 EMS를 복호화함으로써 결국 MS를 얻는다.

#### 키 유도

원칙적으로 밥과 앨리스가 공유한 MS는 이후의 모든 암호화와 데이터 무결성 검사를 위한 대칭 세션키로 사용될 수 있다. 그러나 일반적으로 앨리스와 밥이 각각 다른 암호화키를 사용하고, 암호화와 무결성 검사에도 서로 다른 키를 사용하는 것이 좀 더 안전하다. 따라서 앨리스와 밥은 MS를 이용하여 4개의 키를 생성한다.

#### 데이터 전송

앨리스와 밥이 같은4개의 세션키를 공유하고 있기 때문에, 이제부터 그들은 TCP 연결을 통해 서로에게 안전한 데이터를 보냎 수 있다. TCP가 바이트 스트림 프로토콜이므로, 자연스러운 방법은 TLS가 애플리케이션 데이터를 끊임없이 암호화하고 암호화된 데이터를 TCP에 쉴 새 없이 전달하는 것이다.

#### TLS레코드

![](https://i.ibb.co/w4HPVxZ/temp.png)

처음 세 필드는 암호화되지 않는다. 타입 필드는 레코드가 핸드셰이크 메시지인지 애플리케이션 데이터를 담은 메시지인지 나타낸다.

### 6.2 TLS의 완전한 개념

#### TLS 핸드셰이크

TLS는 앨리스와 밥에게 특정 대칭키 알고리즘이나 공개키 알고리즘을 사용하도록 강제하지 않는다. 대신, TLS는 앨리스와 밥이 TLS 세션의 처음인 핸드세이크 단계에서 사용할 암호화 알고리즘에 합의하게 한다. 게다가 핸드셰이크 단계 동안에 앨리스와 밥은 서로에게 넌스를 보내는데, 이것은 세션키들을 생성하는데 사용된다. 실제 TLS 핸드세이크 과정은 다음과 같다.

1. 클라이언트는 넌스와 함께 자신이 지원하는 암호화 알고리즘의 목록을 보낸다.
2. 목록으로부터 서버는 대칭키 알고리즘(예를 들면, AES), 공개키 알고리즘, 그리고 HMAC 키와 함께 HMAC 알고리즘을 선택한다. 서버는 자신의 선택 결과와 인증서, 서버 넌스를 클라이언트에게 돌려준다.
3. 클라이언트는 인증서를 확인하고 서버의 공개키를 알아낸 후 PMS를 생성한다. 이 PMS를 서버의 공개키로 암호화한 후 서버에게 보낸다.
4. 클라이언트와 서버는 같은 키 유도 함수를 사용하여 PMS와 넌스로부터 독립적으로 MS를 계산한다. 이후 MS는 2개의 암호화 키와 2개의 HMAC 키를 생성하기 위해 분할된다. 선택된 대칭 암호화가 CBC를 이용한다면 연결의 양측을 위해 하나씩, 총 2개의 IV를 MS로부터 얻는다. 이후부터 클라이언트와 서버 간 모든 메시지는 암호화되고 인증된다.
5. 클라이언트는 모든 핸드셰이크 메시지의 HMAC을 전송한다.
6. 서버는 모든 핸드세이크 메시지의 HMAC을 전송한다.
