# 네트워크 계층

# 라우터 내부

[라우터 내부에 무엇이 있을까?](https://velog.io/@dmori_2562/%EB%9D%BC%EC%9A%B0%ED%84%B0-%EC%95%88%EC%97%90-%EB%AC%B4%EC%97%87%EC%9D%B4-%EC%9E%88%EB%8A%94%EA%B0%80)

- `입력 포트`와 `출력 포트`
- `라우팅 프로세서`
- `스위칭 패브릭`(스위칭 구조)

## 입력 포트

- 물리 계층과 링크 계층의 기능을 담당한다.
- 수신된 신호로부터 비트를 저장한다.
- 프레임을 역캡슐화하여 패킷을 추출하고, 오류를 검사하며, 훼손된 경우 패킷을 폐기한다.
- 스위칭 패브릭에 직접 전달되기 전 패킷을 보관하기 위한 버퍼인 큐를 가진다.

## 입력 큐잉

스위치 패브릭을 통해 도착하는 모든 패킷을 지연 없이 전송하려면, 스위치 패브릭이 입력 회선 속도에 비해 충분히 빨라야 한다. 만약 그렇지 않다면 패킷이 스위칭 패브릭을 통해 출력 포트로 전송되기 위해 차례를 기다려야 한다. 이것이 입력 큐잉이다.

### HOL 차단

+@

## 출력 포트

- 입력 포트와 같은 기능을 수행하지만, 이를 역순으로 수행한다.
- 전송을 위해 패킷 선택, 대기열 제거 등을 한다.
- 출력될 패킷이 큐에 들어오면 각 패킷은 프레임으로 캡슐화가 되고 최종적으로 물리 계층에서 프레임을 전기적으로 생성하여 전송한다.

## 출력 큐잉

출력 포트는 시간 단위(패킷 전송 시간)마다 단일 패킷만을 전송할 수 있기 때문에 여러 개 도착한 패킷은 출력 링크를 통한 전송 큐에 대기해야 한다. 결국, 대기 중인 패킷의 수가 출력 포트에서 사용 가능한 메모리를 소모할 만큼 많아질 수 있다.

출력 큐에서는 결과적으로, **전송 대기 중인 패킷 중 링크로 보낼 하나의 패킷을 선택**해야 한다. 이 일은 패킷 스케줄러가 한다.

## 스케줄링 방식

출력 큐에 있는 패킷이 출력 링크를 통해 전송되는, 순서를 결정하는 방법이다.

### First-In-First-Out(FIFO)


출력 링크 큐에 도착한 순서와 동일한 순서로 출력 링크에서 전송할 패킷을 선택한다.

### 우선순위 큐잉

- 우선순위 클래스별로 큐를 생성한다.
- 전송할 패킷을 선택할 때 가장 높은 우선순위 클래스에서 패킷을 전송한다.
- 비선점 우선순위 큐잉에서는 패킷의 전송이 시작되면 중단하지 않는다.

### 라운드 로빈

- 클래스마다 큐를 생성한다. 클래스 간 엄격한 서비스 우선순위는 존재하지 않는다.
- 클래스 간에 서비스를 번갈아서 제공한다.

### WFQ(Weighted Fair Queuing)

- 라우터에서 널리 구현된 라운드 로빈 큐잉의 일반적인 형태이다.
- 작업 보존 큐잉이다.
- 클래스 간에 서비스를 번갈아서 제공하는 점에서 라운드 로빈과 비슷하지만, 각 클래스마다 다른 양의 서비스 시간을 부여 받는다는 점에서 라운드 로빈과 다르다.

## 라우팅 프로세서

- 네트워크 계층의 기능을 수행한다.
- **패킷을 전송할 출력 포트 번호와 다음 홉 주소를 찾기 위해 패킷의 주소를 참조한다.**
- 포워딩 테이블에서 검색하기 때문에 이런 동작은 테이블 검색으로도 알려져있다.
- 최신 라우터에서는 라우팅 프로세서의 이런 기능을 입력 포트에서 작동하도록 하여 더 신속하게 처리하고 있다.

## 스위칭 패브릭

- 라우터의 핵심이며 라우터에서 가장 어려운 일을 담당한다.
- **패킷을 입력 큐에서 출력 큐로 전달한다.**
- 입력 큐가 패킷을 메모리에 저장하고 출력 큐가 메모리로부터 패킷을 읽어오는 방식이다.
- 최근에는 라우터에서 스위칭 패브릭을 사용하는 방식이 다양하다.

## 스위칭 수행 방식

### 메모리

- 가장 단순하다.
- 라우팅 프로세서를 직접 제어해서 입력 포트와 출력 포트 사이에서 패킷을 스위칭한다.

### 버스

- 입력 포트는 라우팅 프로세서의 개입 없이 공유 버스를 통해 직접 출력 포트로 패킷을 전송한다.
- 동시에 여러 패킷이 다른 입력 포트로 라우터에 도착하면 한 번에 하나의 패킷만 버스를 통과할 수 있기 때문에 하나를 제외한 모든 패킷은 대기해야 한다. 모든 패킷의 하나의 버스를 건너가야 하므로, 라우터의 교환 속도는 버스 속도에 의해 제한된다.

### 크로스바

- N개의 입력 포트를 N개의 출력 포트에 연결하는 2N 버스로 구성된 인터커넥션 네트워크이다.
- 출력 포트로 전달되는 패킷을 다른 패킷이 현재 해당되는 출력 포트로 전달되지 않는 한 해당 출력 포트에 도달하는 것을 차단하지 않는다.
- 두 개의 서로 다른 입력 포트에서 나오는 두 개의 패킷이 동일한 출력 포트로 보내지는 경우 한 번의 하나의 패킷만 특정 버스에서 전송될 수 있기 때문에 이런 경우 입력 포트에서 기다려야 한다.

## 라우터의 성능(품질) 결정 요소

- 라우팅 프로세서의 속도
- 테이블 유지
- 출력 포트 결정 방법
- 스위치

# 라우팅 알고리즘

### 유니캐스트 라우팅

IP에서 데이터그램이 단지 하나의 목적지를 가지는 것을 말한다. == 일대일 전송

이 라우팅 방식에서 패킷은 포워딩 테이블을 참조하여 목적지까지 홉 단위로 전달된다. 네트워크에 있는 라우터들에게는 이를 위한 목적지까지 가능한 빠른 도착이 가능하게 해 주는 포워딩 테이블이 필요하다.

### 최소비용 트리

인터넷에 N개의 라우터가 있다면, 각 라우터에서 다른 라우터로의 최소비용 경로는 N-1개 존재한다. 즉, 모든 인터넷 연결에 대해 N*(N-1)개의 최소비용 경로가 필요하다.

최소비용 트리는 **모든 경로를 살펴보는 좋은 방법**이다. 이 방식은 곧 비용을 기반으로 하는 스패닝 트리를 만드는 것이다.

**최소비용 트리와 포워딩 테이블을 만들기 위한** 몇 가지 라우팅 알고리즘이 있고, 이 알고리즘들은 최소비용과 각 노드에서 최소비용 트리를 만드는 방법이 각각 다르다.

### 최소비용 트리를 만들기 위한 3가지 알고리즘 요약

## 링크 상태(LS) 라우팅 알고리즘

### 특징

- 인터넷에서 네트워크를 나타내는, 링크의 특성을 결정하기 위해 링크 상태를 사용한다.
- 비용은 링크의 상태를 정의한 엣지로 구성된다.
- LSDB(Link-State Database)라는 네트워크상의 모든 노드를 매트릭스 형태로 만든 정보를 가지는 링크 상태 데이터베이스를 사용한다.
- 각 노드가 각 링크의 상태를 알기 위해서는 네트워크에 관한 완전한 맵이 필요하다.
    
- 모든 인터넷에 대해 LSDB는 하나만 존재한다. 최소비용 트리 작성 시 복사본이 필요하다.

### 다익스트라 알고리즘

공유된 LSDB를 사용하여 최소비용 트리를 작성하기 위해 각 노드가 사용하는 알고리즘이다. 세 가지 단계로 구성되어 있다.

1. LSDB의 정보를 기반으로 하여 각 노드의 전체 비용을 계산한다.
2. 트리에 없는 모든 비용은 업데이트되어야 한다.
3. 트리에 모든 노드가 추가될 때까지 2를 반복한다.

## 거리 벡터(Distance-Vector, DV) 라우팅 알고리즘

### 특징

- 분산적: 각 노드는 하나나 그 이상의 직접 연결된 이웃으로부터 정보를 받고, 계산을 수행하며, 계산된 결과를 다시 그 아웃들에게 배포한다.
- 반복적: 이웃끼리 더 이상 정보를 교환하지 않을 때까지 프로세스가 지속된다.
- 비동기적: 톱니바퀴 돌듯이 모든 노드가 서로 정확히 맞물려 동작할 필요가 없다.

### 벨만-포드 알고리즘

- 거리 벡터 라우팅 알고리즘의 핵심 아이디어이다.
- 발신지 노드-중계 노드 사이의 비용과, 중계 노드-목적지 노드 사이의 비용이 주어졌을 때 중계 노드를 통과하는 발신지 노드-목적지 노드 사이의 최소비용을 찾기 위해 사용된다.
    
    $$
    Dxy= min(c(x, v) + d(v, y))
    
    $$
    
- 만약 v 대신 z를 통과하는 거리가 더 짧다면, 테이블을 업데이트한다.
 
    $$
    Dxy= min(c(x, z) + d(z, y))
    
    $$
    

### 문제점: 무한대로의 카운트

비용 감소와 같은 좋은 소식은 빠르게 확산되지만, 비용 증가와 같은 나쁜 소식은 천천히 확산된다. 예를 들어, 링크 비용 증가나 링크가 끊어진 것과 같은 소식은 천천히 확산된다.

### 두 노드 루프에서의 해결법: 수평 분할과 포이즌 리버스

- 수평 분할: 각 인터페이스를 통해 테이블을 플러딩하는 대신, 각 인터페이스를 통해 자신의 테이블의 일부만을 전송한다. → 좋은 소식과 나쁜 소식 모두 반영되지 않는다.
- `**포이즌 리버스**`: `**타이머**`를 사용하여, 만약 **일정 시간동안 경로상에 새로운 소식이 없으면 테이블에서 해당 경로를 제거한다.**
- 세 노드 이상에서는 위의 방법으로 해결이 불가능하다.

## 경로 벡터(Path-Vector, PV) 라우팅 알고리즘

### 특징

- 경로에 비용을 할당하지 않고, 패킷이 가장 효율적으로 목표에 도달할 수 있도록 하는, 단순한 목표를 가진 알고리즘이다.
- 출발지에서 모든 목적지까지의 경로는 `**스패닝 트리**`에 의해 결정된다.
- 스패닝 트리는 최소비용 트리가 아니다. 방문 노드의 수를 최적화시키는 트리이다. 즉, **비용을 고려하지 않고 노드 수만 고려**한다. 이 방식을 사용하면, **비용이 반영되지 않은 트리**가 완성된다.
- 스패닝 트리는 각 노드에서 점진적, 비동기적으로 만들어진다.
- 스패닝 트리는 노드가 부팅될 때 이웃으로부터 얻게 되는 정보를 기반으로 경로 벡터를 작성한다.
- 노드는 자신에 대한 정보를 자신의 근접 이웃들에게 전달한다.

# 인터넷 프로토콜(IP)

## IPv4 데이터그램 형식

참고: [IPv4 헤더](http://www.ktword.co.kr/test/view/view.php?m_temp1=1859), [IP 데이터그램의 구조](https://codedragon.tistory.com/7390)

### 버전 번호

- 4비트로 데이터그램의 IP 프로토콜 버전을 명시한다.
- 라우터는 버전 번호를 확인하여 데이터그램의 나머지 부분을 어떻게 해석할지 결정한다. → IP 버전마다 데이터그램의 형식이 다르다.

### 헤더 길이

- 헤더 길이를 표시한다. 헤더 길이는 대체로 20바이트이다.
- IP 데이터그램에서 실제 페이로드가 시작하는 곳을 결정한다.

### 서비스 타입

- 헤더 길이를 표시한다. 헤더 길이는 대체로 20바이트이다.
- IP 데이터그램에서 실제 페이로드가 시작하는 곳을 결정한다.

### 데이터그램 길이

- IP 헤더 및 데이터를 포함한 IP 패킷(데이터그램) 전체의 길이를 바이트 단위로 표시한다.

### 식별자, 플래그, 단편화 오프셋

- IP 단편화와 관계가 있다. IPv6는 단편화를 허용하지 않는다.

### TTL(Time-to-live)

- IP 패킷의 수명, 즉 데이터그램이 지날 수 있는 라우터 수에 대한 생존 시간
- 라우터가 데이터그램을 처리할 때마다 감소하며, TTL 필드가 0이 되면 라우터가 데이터그램을 폐기한다.
- 네트워크에서 데이터그램이 무한히 순환하지 않도록 도와준다.

### 상위 계층 프로토콜 ID

- 어느 상위계층 프로토콜이 데이터 내에 포함되었는가를 보여준다.
- 데이터가 전달될 목적지의 전송 계층의 특정 프로토콜을 명시한다.
- 일반적으로 IP 데이터그램이 최종 목적지에 도착했을 때만 사용된다.
- 포트 번호가 전송 계층과 응용 계층을 함께 묶는 접착제 연락을 하는 것처럼, 프로토콜 번호는 네트워크 계층과 전송 계층을 묶는 역할을 한다.

### 헤더 체크섬

- **라우터가 수신한 IP 데이터그램의 비트 오류를 탐지**하는 데 도움을 준다.
- 헤더에서 각 2바이트를 수로 처리하고 1의 보수를 합산하여 계산한 것이다.
- 라우터는 수신한 각 IP 데이터그램마다 헤더 체크섬을 계산하고 이 값과 데이터그램 헤더의 체크섬이 다르면 오류 상태임을 감지한다. 라우터는 보통 오류가 검출된 데이터그램을 폐기한다.

### 출발지와 목적지 IP 주소

- 출발지가 데이터그램을 생성할 때, 자신의 IP 주소를 출발지 IP 주소 필드에 삽입하고, 목적지 IP 주소를 목적지 IP 주소 필드에 삽입한다.
- 출발지 호스트는 DNS 검색을 통해 목적지 주소를 결정하기도 한다.

### 옵션

- IP 헤더를 확장한다.

### 데이터(페이로드)

- 대부분의 경우 목적지에 전달하기 위해 전송 계층 세그먼트(TCP, UDP)를 포함한다.
- 데이터그램이 존재하는 이유이자 가장 중요한 필드이다.

## IPv4 데이터그램 단편화

각 라우터는 각기 다른 `MTU(링크 계층 프레임이 전달할 수 있는 최대 데이터 양)`을 가진 서로 다른 링크 계층 프로토콜을 가진다. 한 링크에서 IP 데이터그램을 받으면 출력 링크를 결정하기 위해서 전달 테이블을 검사한다. 이때 출력 링크가 IP 데이터그램의 길이보다 작은 MTU를 가지는 상황이라면 어떻게 해야 할까?

해결책은 **IP 데이터그램의 페이로드를 두  개 이상의 더 작은 IP 데이터그램으로 분할하고 각각의 더 작아진 IP 데이터그램을 별도의 링크 계층 프레임으로 캡슐화하여 출력 링크로 보내는 것**이다. 이러한 작은 데이터그램 각각을 `**단편(fragment)**`이라고 한다.

**조각들은 데이터링크 계층에 전달되기 전에 네트워크 계층에서 미리 분할되고, 목적지 전송 계층에 도달하기 전에 재결합되어야 한다.** 네트워크 코어를 간단하게 유지하기 위해 IPv4 설계는 데이터그램 재결합이 네트워크 라우터가 아닌 종단 시스템에서 이루어지도록 했다.

목적지 호스트가 데이터그램 재결합을 수행할 수 있도록, IPv4 설계자는 식별자, 플래그, 단편화 오프셋 필드를 IP 데이터그램 헤더에 넣었다.

- 식별자: 데이터그램이 전송된 발신지 호스트 구분
- 플래그: 단편화 금지, 단편화 가능, 추가 단편화 가능 표시 정의
- 단편화 오프셋: 전체 데이터그램에서 해당 단편의 상대적인 위치

## IPv4 주소체계

- IP 계층에서 사용되는 식별자
- 32비트 주소로 라우터나 전세계 모든 호스트의 인터넷 연결을 범용적이고 유일하게 만들하게 만들어 준다.
- 32비트 주소를 사용하기 때문에 주소공간은 2^32가 된다.

### 서브넷

참고: [https://engkimbs.tistory.com/622](https://engkimbs.tistory.com/622)

IP 부족 문제를 해결하기 위해 IP를 사용하는 네트워크 장치 수에 따라 효율적으로 사용할 수 있는 방식이다. 서브넷은 IP 주소에서 네트워크 영역을 부분적으로 만든 부분 네트워크이다. **세 호스트들의 인터페이스들과 하나의 라우터 인터페이스로 연결된 네트워크로 구성**된다. 

서브넷 마스크는 ‘223.1.1.0/24’라는 32비트 IP 주소 중 24 부분을 가리키며, 이는 왼쪽 24비트가 서브넷 주소라는 것을 의미한다.

서브넷을 결정하기 위해서는 먼저 호스트나 라우터에서 각 인터페이스를 분리하고, 고립된 네트워크를 만든다. 이렇게 고립된 네트워크의 종단점은 인터페이스의 끝이 되고, 그 각각을 서브넷이라고 부른다.

### 브로드캐스트 주소

호스트가 목적지 주소가 ‘255.255.255.255’인 데이터그램을 보내면, 이 메시지는 같은 서브넷에 있는 모든 호스트에게 전달된다. 마찬가지로, 라우터는 선택적으로 이웃 서브넷에 메시지를 전달한다.

### DHCP

- IP 주소를 동적으로 부여하는 네트워크에서 사용하는 프로토콜
- 고정 IP 주소를 부여하는 것이 아닌, 임시 IP 주소를 부여한다.
- 서버/클라이언트 형식의 응용 계층 프로토콜로, 실질적으로 TCP/IP 계층을 보조한다.
- 기관 내의 주소지정을 자동으로 설정(네트워크에서 자동으로 호스트와 연결)하므로, 플러그 앤 플레이 프로토콜 또는 제로 구성 프로토콜이라고 한다. 이 능력은 작업을 수동으로 수행하는 네트워크 관리자에게 매우 유익하다.
- 호스트가 빈번하게 접속하고 떠나는 가정 인터넷 접속 네트워크, 엔터프라이즈 네트워크, 무선 LAN에서도 폭넓게 사용한다.
- Well-Known 포트인 67번, 68번 포트를 사용한다.
- UDP 서비스를 사용한다. DHCP의 오류 제어는 요청에 대한 DHCP 응답을 받지 못할 경우 타이머와 재전송 정책을 사용하여 이루어진다. 검사합을 사용하는 것은 선택사항이다.
- 동작 예
    - DHCP 서버가 있는 경우: 메시지를 DHCP 서버에 바로 날리면 된다. 자기 주소가 없으므로 0으로만 채우거나, Magic Address(99.130.83.99)로 채운다.
    - DHCP 서버가 없는 경우: 브로드캐스팅을 통해 DHCP 서버를 찾는다.

## 네트워크 주소 변환(NAT)

- 주소 매핑 기술로, 사설 주소와 범용 주소의 매핑을 제공하고, 동시에 가상 사설 네트워크를 지원한다.
- 하나의 네트워크에서, 내부 통신을 위해 사설 주소를 사용하는 동시에, 다른 네트워크와의 통신을 위해 범용 인터넷 주소를 사용할 수 있도록 지원한다.
- 해당 네트워크의 글로벌 인터넷 연결은 NAT 기능이 있는 라우터를 통해 이루어진다.
    
- NAT 라우터를 통해 나가는 모든 패킷의 발신지 주소는 범용 NAT 주소로 변환된다.
- NAT 라우터를 통과하는 모든 들어오는 패킷의 목적지 주소(범용 NAT 주소)는 적절한 사설 주소로 변환된다.
- 이는 변환 테이블을 통해 매핑된다.

## IPv6

IPv4의 32비트 IP 주소 공간이 빠른 속도로 고갈되어 있음을 깨닫고 개발했다.


### IPv4와의 차이

- 확장된 주소 기능: 주소 크기 32비트 → 128비트, 앞으로 IP 주소가 고갈되는 일은 발생하지 않는다. 애니캐스트 주소(호스트 그룹의 어떤 이에게도 전달 가능한 주소)가 도입되었다.
- 간소화된 40바이트 헤더: IPv4의 많은 필드가 생략되거나 옵션으로 남겨졌다. 40비트 고정 길이 헤더는 라우터가 IP 데이터그램을 더 빨리 처리하게 해준다. 새로운 옵션 부호화는 유연한 옵션 처리를 가능하게 한다.
- 흐름 라벨링
- 버전: IP 버전 번호 인식
- 트래픽 클래스: IPv4의 TOS 필드와 비슷한 의미로, 흐름 내의 SMTP 이메일 같은 애플리케이션의 데이터그램보다 voice-over-IP 같은 특정 응용 데이터그램에 우선 순위를 부여하는 데 사용된다.
- 흐름 라벨: 데이터그램의 흐름을 인식하는 데 사용된다.
- 페이로드 길이: 부호 없는 정수
- 다음 헤더: IPv4의 프로토콜 필드와 같다.
- 단편화/재결합을 수행하지 않는다: 라우터에서 이 기능을 삭제하고 종단 시스템이 하도록 하여 IP 전달 속도를 증가시킨다.
- 헤더 체크섬: 전송 계층 프로토콜과 데이터 링크 프로토콜이 체크섬을 수행하므로 네트워크 계층에서의 체크섬 기능이 빠져도 된다.
- 옵션 필드 제거: 표준 IP 헤더 필드에서 제거되었으나, 다음 헤더 중 하나로 사용될 수 있다. → IPv4 표준 기준으로 헤더의 고정 길이가 40바이트가 되었다.

# 인터넷 제어 메시지 프로토콜(ICMP)

참고: [인터넷 제어 메시지 프로토콜](https://www.ibm.com/docs/ko/aix/7.1?topic=protocols-internet-control-message-protocol)

### 특징

- 호스트와 라우터가 서로 간에 네트워크 계층 정보를 주고받기 위해 사용된다.
- 종종 IP의 한 부분으로 간주되지만, ICMP 메시지가 IP 데이터그램에 담겨 전송되므로, 구조적으로는 IP 바로 위에 있다.
TCP/UDP 세그먼트가 IP 페이로드로 전송되는 것처럼 ICMP 메시지도 IP 페이로드로 전송된다. TCP/UDP와 마찬가지로 다중화/역다중화도 일어난다.
- **커널에 임베드되며, API가 제공되지 않는다.**
- 통신 환경의 문제점에 관한 피드백을 제공하지만, 그것이 **IP를 신뢰 가능한 프로토콜로 만들지는 않는다.**
- 오류 보고에 사용된다. 그 예로, HTTP 연결을 수행할 때 발생하는 “목적지 네트워크에 도달할 수 없음” 메시지가 있다. 네트워크의 어떤 지점에서 IP 라우터가 HTTP 요청 메시지에 명시된 호스트로 가는 경로를 찾을 수 없을 때, 그 라우터는 우리의 호스트에게 오류가 발생했음을 알리기 위해 ICMP 메시지를 보낸다.
- ping 프로그램에 사용된다. ICMP 메시지를 특정 호스트에 보내면, 목적지 호스트는 에코 요청을 보고 나서 ICMP 응답을 보낸다.

### 메시지 타입

| ICMP 타입 | 코드 | 설명 |
| --- | --- | --- |
| 0 | 0 | 에코 응답 - ping 프로그램에서 사용 |
| 3 | 0 | 목적지 네트워크 도달 불가능 |
| 3 | 1 | 목적지 호스트 도달 불가능 |
| 3 | 2 | 목적지 프로토콜 도달 불가능 |
| 3 | 3 | 목적지 포트 도달 불가능 |
| 3 | 6 | 목적지 네트워크 찾지 못함 |
| 3 | 7 | 목적지 호스트 찾지 못함 |
| 4 | 0 | 출발지 억제 - 혼잡 제어를 위한 것으로, 혼잡이 발생한 라우터가 호스트의 전송속도를 늦추도록 ICMP 출발지 억제 메시지를 해당 호스트에 보낸다. 실제로는 잘 사용되지 않는데, TCP 같은 경우 출발지 억제 메시지가 없어도 전송 계층에서 동작하는 자신만의 혼잡제어 메커니즘을 가지고 있기 때문이다. |
| 8 | 0 | 에코 요청 |
| 9 | 0 | 라우터 알림 |
| 10 | 0 | 라우터 발견 |
| 11 | 0 | TTL 만료 |
| 12 | 0 | IP 헤더 불량 |

# **IP 주소는 무엇이며, 어떤 기능을 하고 있나요?**

IP 주소는 네트워크 계층의 IP에서 사용되는 식별자입니다. IP 주소는 라우터나 전세계 모든 호스트의 인터넷 연결을 범용적이고 유일하게 만들어 줍니다.

- IPv6는 IPv4의 주소 고갈 문제를 해결하기 위해 만들어졌지만, 아직도 수많은 기기가 IPv4를 사용하고 있습니다. 고갈 문제를 어떻게 해결할 수 있을까요?
    
    IPv4를 사용하면서 고갈 문제를 해결하고 싶다면, NAT를 활용하여 해결합니다. NAT를 활용하면 사설 IP 주소를 사용하면서, 공인 IP 주소와 상호변환할 수 있습니다. 이는 결론적으로 공인 IP 주소를 다수가 함께 사용할 수 있게 해 줍니다.
    
- IPv4와 IPv6의 차이에 대해 설명해 주세요.
    
    참고: [https://www.juniper.net/kr/ko/research-topics/what-is-ipv4-vs-ipv6.html](https://www.juniper.net/kr/ko/research-topics/what-is-ipv4-vs-ipv6.html)
    
    - IPv4는 패킷을 단편화하지만, IPv4는 단편화를 하지 않습니다.
    - IPv4의 주소 공간은 32비트, IPv6의 주소 공간은 128비트입니다.
    - IPv6에서는 IPv4의 많은 필드가 생략되거나 옵션으로 남겨졌습니다. 40비트 고정 길이 헤더는 라우터가 IP 데이터그램을 더 빨리 처리하게 해줍니다.
    - IPv4는 멀티캐스트를 위해 클래스 유형의 주소 공간을 사용하지만, IPv6는 통합된 주소 공간을 사용합니다.
    - IPv4는 각 디바이스가 멈추고 패킷을 확인하도록 강제하는 브로드캐스트 주소를 사용합니다. IPv6는 멀티캐스트 그룹을 사용합니다.
    - IPv4는 0.0.0.0을 미지정 주소로 사용하고 클래스 유형 주소(127.0.0.1)를 루프백에 사용합니다. IPv6는 미지정 주소에는 ::을, 루프백에는 ::1을 사용합니다.
    
- IPv4를 사용하는 장비와 IPv6를 사용하는 같은 네트워크 내에서 통신이 가능한가요? 가능하다면 어떤 방법을 사용하나요?
- IP가 송신자와 수신자를 정확하게 전송되는 것을 보장해 주나요?
- IPv4에서 수행하는 Checksum과 TCP에서 수행하는 Checksum은 어떤 차이가 있나요?
- TTL(Hop Limit)이란 무엇인가요?
- IP 주소와 MAC 주소의 차이에 대해 설명해 주세요.

# **라우터 내의 포워딩 과정에 대해 설명해 주세요.**

라우팅 알고리즘을 통해 포워딩 테이블을 만듭니다. 그리고 포워딩 테이블을 참조하여 패킷을 이동시킵니다.

- 라우팅과 포워딩의 차이는 무엇인가요?
    
    라우팅은 출발지에서 목적지까지의 경로를 결정하는 것이고, 포워딩은 라우터의 입력 포트에서 출력 포트로 패킷을 이동시키는 것입니다.
    
- 라우팅 알고리즘에 대해 설명해 주세요.
    
    라우팅 알고리즘은 크게 3가지로 나눌 수 있습니다.
    
    링크 상태 알고리즘은 LSDB(Link-State Database)라는 네트워크상의 모든 노드를 매트릭스 형태로 만든 정보를 가지는 링크 상태 데이터베이스를 사용합니다. 이는 다익스트라 알고리즘을 통해 구현됩니다.
    
    거리 벡터 알고리즘은 분산적, 반복적, 비동기적 특징을 띱니다. 이 알고리즘은 벨만-포드 알고리즘을 통해 구현되며, 비용 감소와 같은 좋은 소식은 빠르게 확산되지만, 비용 증가와 같은 나쁜 소식은 천천히 확산되는 단점이 있습니다. 이 단점을 해결하기 위해 포이즌 리버스라는 방법을 사용합니다. 포이즌 리버스는 타이머를 사용하여 일정 시간동안 경로상에 새로운 소식이 없으면 테이블에서 해당 경로를 제거하는 방식입니다.
    
    경로 벡터 알고리즘은 경로에 비용을 할당하지 않고, 패킷이 가장 효율적으로 목표에 도달할 수 있도록 하는 알고리즘입니다. 출발지에서 모든 목적지까지의 경로는 스패닝 트리(트리의 모든 노드를 이을 수 있지만, 사이클은 발생하지 않는 트리)에 의해 결정됩니다. 이 알고리즘은 비용은 고려하지 않고 통과하는 노드의 수만 고려합니다.
    
- 포워딩 테이블의 구조에 대해 설명해 주세요.
    
    포워딩 테이블은 라우팅 알고리즘을 통해 만들어진, 전송 비용이 가장 적게 드는 경로를 저장해둔 테이블입니다. 여기에는 원격 네트워크나 직접 연결한 네트워크에 대한 경로 정보가 들어있습니다. 즉, 입력 포트와 출력 포트 정보가 들어있습니다.
    

# **서브넷 마스크와, 게이트웨이에 대해 설명해 주세요.**

서브넷 마스크는 IP 주소와 AND 연산하여 Network 부분의 정보를 걸러내기 위한 목적으로 만들어졌습니다.

- NAT에 대해 설명해 주세요.
    
    주소 매핑 기술로, 사설 주소와 범용 주소의 매핑을 제공하고, 동시에 가상 사설 네트워크를 지원합니다. 하나의 네트워크에서, 내부 통신을 위해 사설 주소를 사용하는 동시에, 다른 네트워크와의 통신을 위해 범용 인터넷 주소를 사용할 수 있도록 지원합니다.
    
- 서브넷 마스크의 표현 방식에 대해 설명해 주세요.
    
    IP 주소와 같이 32비트 이진수로 표현합니다. 또한, 연속된 1와 0으로 구성되어 있습니다.
    
- 그렇다면, 255.0.255.0 같은 꼴의 서브넷 마스크도 가능한가요?
    
    255.0.255.0은 11111111.00000000.11111111.00000000로 표현되기 때문에 서브넷 마스크로 사용할 수 없습니다.