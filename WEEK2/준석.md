# 트랜스포트 계층

## 1. 트랜스포트 계층 서비스 및 개요

- UDP : 비신뢰적, 비연결형 서비스이며 생성하는 패킷을 데이터그램이라고 한다.
- TCP : 신뢰적, 연결형 서비스이며 생성하는 패킷을 세그먼트라고 한다.
- IP : 세그먼트의 전달을 보장하지 않고, 세그먼트의 순서도 보장하지 않으며, 내부 데이터의 무결성도 보장하지 않는 비신뢰적인 서비스

TCP와 UDP의 역할은 Host 사이의 IP 전달 서비스를 Host에서 동작하는 Process사이의 전달 서비스로 확장하는것이다. 이를 트랜스포트 계층 다중화(transport-layer-multiplexing)와 역다중화(demultiplexing)라고 부른다.

UDP와 TCP 둘 다 Header에 오류검출 필드를 포함함으로써 무결성 검사를 제공하는데 이는 UDP가 제공하는 최소한의 2가지 서비스 중 하나이며 UDP는 IP와 마찬가지로 비신뢰적인 서비스다. 반면에, TCP는 **신뢰적인 데이터 전송**을 제공하는데, 흐름 제어, 순서 번호, 확인 응답, 타이머를 사용함으로써 수신하는 프로세스에게 데이터가 순서대로 정확하게 전달되도록 한다. 이런 방식으로 비신뢰적인 IP 서비스를 프로세스 사이의 신뢰적인 데이터 전송 서비스로 만들어준다. 또한 TCP는 혼잡 제어를 사용하는데, 이는 한 TCP연결이 과도한 트래픽으로 Host간의 스위치와 링크를 혼잡하게 하는 걸 방지하기 위해 송신측의 TCP가 네트워크에 보낼 수 있는 트래픽을 조절함으로써 수행된다. 반면 UDP 트래픽은 조절되지 않아서 원하는 속도로 데이터를 보낼 수 있다.

## 2. 다중화와 역다중화

Host내에서 트랜스포트 계층은 바로 아래의 네트워크 계층으로부터 세그먼트를 수신하고 해당 프로세스의 소켓으로 전달한다. 이 때 소켓이 여러개 존재할 수 있는데, 포트별 식별자로 구분되며 이 식별자의 포맷은 소켓이 UDP 소켓인지 TCP 소켓인지에 따라 달라진다. 각 트랜스포트 계층 세그먼트는 향하는 소켓을 식별할 수 있도록 필드 집합을 가지고 있다. 이를 검사하여 세그먼트의 데이터를 올바른 소켓으로 보내는 작업을 **역다중화(demultiplexing)**라고 한다. 이와 반대로 Host에서 소켓으로부터 데이터를 모으고, 이에 대한 세그먼트를 생성하기 위해 각 데이터에 헤더 정보로 캡슐화하고, 그 세그먼트들을 네트워크 계층으로 전달하는 작업을 **다중화(multiplexing)**라고 한다.

트랜스포트 계층 다중화에는 2가지 요구사항이 존재한다.

- 소켓은 유일한 식별자를 갖는다.
- 각 세그먼트를 세그먼트가 전달될 소켓을 가리키는 특별한 필드를 갖는다.(출발지 포트 번호 필드, 목적지 포트 번호 필드)

### 비연결형 다중화화 역다중화

UDP소켓을 통해 데이터가 전송될 때, 트랜스포트 계층에서 출발지 포트번호와 목적지 포트번호를 포함하는 세그먼트를 생성한다. 그리고 네트워크 계층에서는 출발지 IP주소와 목적지 IP주소로 다시 캡슐화하고 목적지로 전송하는데, 이후 전달받은 Host에서는 이 과정을 역순으로 진행한다.

### 연결지향형 다중화와 역다중화

TCP 소켓은 UDP 소켓과 다르게 출발지 IP주소, 목적지 IP주소, 출발지 포트번호, 목적지 포트번호 4가지로 식별된다. 목적지 IP주소와 목적지 포트번호가 같더라도 출발지 IP주소가 다르거나 출발지 포트번호가 다르면 다른 소켓으로 가는 것이다.

### 웹 서버와 TCP

TCP 연결소켓과 프로세스가 항상 1:1 관계를 가지는것은 아니며 하나의 프로세스만 사용하면서 각각의 새로운 클라이언트 연결을 위해 새로운 연결 소켓과 함께 새로운 스레드를 생성한다. 이러한 웹 서버에서는 하나의 같은 프로세스에 붙어있는 많은 연결소켓들이 동시에 존재할 수 있다.

## 3. 비연결형 트랜스포트: UDP

신뢰적인 데이터 전송 서비스를 제공하는 TCP에 비해 UDP를 사용하는 이유는 뭘까?

- TCP의 혼잡제어 등은 신뢰적인 데이터 전송을 보장하지만 시간은 보장하지 않는다. 이에 조금의 데이터 손실을 허용되지만 속도가 중요한 경우에 사용한다.
- 3-way handshaking에 걸리는 지연 시간이 없다.
- 연결 상태가 없으므로 일반적으로 좀 더 많은 액티브 클라이언트를 수용할 수 있다.
- TCP는 세그먼트마다 20바이트의 헤더 오버헤드를 갖지만, UDP는 단지 8바이트의 오버헤드를 갖는다.

| 애플리케이션          | 애플리케이션 계층 프로토콜 | 하위 트랜스포트 프로토콜   |
| --------------------- | -------------------------- | -------------------------- |
| 전자메일              | SMTP                       | TCP                        |
| 원격 터미널 접속      | 텔넷                       | TCP                        |
| 보안 원격 터미널 접속 | SSH                        | TCP                        |
| 웹                    | HTTP, HTTP/3               | TCP(HTTP용), UDP(HTTP/3용) |
| 파일 전송             | FTP                        | TCP                        |
| 원격 파일 서버        | NFS                        | 일반적으로 UDP             |
| 스트리밍 멀티미디어   | DASH                       | TCP                        |
| 인터넷 폰             | 통상 독점 프로토콜         | UDP or TCP                 |
| 네트워크 관리         | SNMP                       | 일반적으로 UDP             |
| 이름 변환             | DNS                        | 일반적으로 UDP             |

실시간성이 중요한 애플리케이션의 경우에는 UDP를 많이 사용하지만 최근에 QUIC 프로토콜이 생겨나면서 UDP상에서는 신뢰적인 데이터전송이 구축가능해져 애플리케이션 프로세스들은 TCP의 혼잡 제어 메커니즘에 의해 전송률 억제를 강요당하지 않고도 신뢰적으로 통신할 수 있다.

### UDP 세그먼트 구조

UDP 헤더는 2바이트씩 구성된 단 4개의 필드만을 갖는다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbaj37h%2FbtrF3Z7Qlii%2FegZQHiKQR1Os5khJA6W78k%2Fimg.png)

### UDP 체크섬

UDP 체크섬은 오류 검출을 위한 것이다. 송신자 측에서 체크섬은 UDP의 세그먼트 안에 있는 모든 16bit 워드들의 합산에 다시 1의 보수를 수행해 만든다. 합산과정에서 발생하는 오버플로는 윤회식 자리올림은 한다. 이를 통해 수신자 측에서는 수신한 세그먼트내의 모든 16bit 워드들의 합산에 체크섬을 더해서 1111111111111111 이 되는지를 확인함으로써 데이터가 오류없이 잘 전송되었는지를 체크할 수 있다.

많은 링크계층 프로토콜에서 오류검사를 제공하지만 그렇지 않은 링크계층도 있기 때문에 항상 오류 검사가 보장되지 않으므로 **종단과 종단의 원칙(end-end principle)**에 의해 트랜스포트 계층에서 오류검사를 제공해야 한다. UDP는 오류검사를 제공하지만 오류를 회복하기 위한 어떤일도 하지 않는다. 일부 UDP 구현에서는 손상된 세그먼트를 그냥 버리기도 하고, 다른 구현에서는 경고와 함께 손상된 세그먼트를 애플리케이션에 넘겨주기도 한다.

## 4. 신뢰적인 데이터 전송의 원리

트랜스포트 프로토콜에서 신뢰적 데이터 전송(reliable data transfer) 서비스를 제공하더라도 하위 계층에서 비신뢰적인 서비스를 제공할 수 있다. 그런점까지 고려해 어떻게 신뢰적인 데이터 전송 서비스를 구축하는지 알아보자.

### 4.1 신뢰적인 데이터 전송 프로토콜의 구축

#### 완벽하게 신뢰적인 채널상에서의 신뢰적인 데이터 전송: rdt1.0

![](https://velog.velcdn.com/images%2Fkms9887%2Fpost%2F9e24398d-8c21-47ab-a85a-60dad7189c59%2Fimage.png)

rdt 1.0의 송신자와 수신자에 대한 유한상태 머신(finite-state machine, FSM)은 위 그림과 같다. 좌측의 FSM은 송신자의 동작을 정의하고 우측의 FSM은 수신자의 동작을 정의한다. 각 FSM은 각각 하나의 상태만을 갖고 있고, 화살표는 한 상태로부터 다른 상태로의 전이를 나타낸다. 전이를 일으키는 event는 변화를 표기하는 가로선 위에 나타내고 event가 발생했을 때 취해지는 action은 가로선 아래에 나타낸다. event 발생 시 어떠한 action도 취해지지 않거나 어떠한 event 발생 없이 action이 취해질 때, action이나 event가 없음을 표시하기 위해 기호 $\Lambda$를 사용한다. FSM의 초기 상태는 점선 화살표로 표시된다.

그림에서 rdt의 송신측은 rdt_send(data) event에 의해 상위 계층으로부터 데이터를 받아들이고 데이터를 포함한 패킷을 생성한다. 그리고 패킷을 채널로 송신한다. 수신측 rdt에서는 rdt_rcv(packet) 이벤트에 의해 하위의 채널로부터 패킷을 수신하고, 패킷으로부터 데이터를 추출한 후 데이터를 상위 계층으로 전달한다.

#### 비트 오류가 있는 채널상에서의 신뢰적인 데이터 전송: rdt2.0

패킷이 손상될 수 있는 통신에서 수신자는 전달된 패킷이 모두 올바르다면 긍정 확인응답을, 올바르지 않다면 부정 확인응답을하는 **자동 재전송 요구(Automatic Repeat reQuest, ARQ)**프로토콜을 사용한다. 비트 오류를 처리하기 위해 기본적으로 다음 3가지 부가 프로토콜 기능이 ARQ 프로토콜에 요구된다.

- 오류 검출 : 인터넷 체크섬 필드를 사용해 오류를 검출한다.
- 수신자 피드백 : 긍정 확인응답(ACK 패킷) 혹은 부정 확인응답(NAK 패킷)을 통해 송신자는 수신자의 상태를 알 수 있다.
- 재전송 : 수신자에서 오류를 가지고 수신된 패킷은 송신자에 의해 재전송된다.

![](https://i.ibb.co/M20K2T6/temp.png)

rdt의 송신 츠긍 2개의 상태를 갖는다. 왼쪽 상태에서는 상위 계층으로부터 데이터가 전달되기를 기다리고 rdt_send(data) event가 발생하면, 송신자는 패킷 체크섬과 함께 전송될 데이터를 포함하는 패킷(sndpkt을 생성하고, 그 패킷을 udt_send(sndpkt)을 동작을 통해 전송한다. 오른쪽 상태에서 송신자 프로토콜은 수신자로부터의 ACK 또는 NAK 패킷을 기다린다. ACK 패킷이 수신되면 송신자는 다시 왼쪽 상태로 돌아가고 NAK 패킷이 수신되면 프로토콜은 마지막 패킷을 재전송하고 재전송된 패킷에 대한 응답을 다시 기다린다. 송신자가 ACK 또는 NAK 패킷을 기다리는 상태일 때, 상위 계층으로부터 더 이상 데이터를 전달받을 수 없다. 이러한 행동 때문에 이와 같은 프로토콜은 전송 후 대기(stop-and-wait) 프로토콜로 알려져 있다.

rdt2.0에 대해 수신자 측 FSM은 아직 단일 상태를 갖는다. 패킷이 도착하면 수신자는 패킷의 손상여부를 파악하고 ACK 또는 NAK 패킷으로 응답한다. 이 모델에서는 ACK, NAK 패킷이 손상될 수 있다는 결함이 있다. 이를 해결하기 위한 3가지 가능성을 고려해보자.

- 손상된 ACK, NAK 패킷에 대해 송신자가 해당 패킷의 재전송을 요구하는 것(무한 루프에 빠질 수 있는 가능성이 있다.)
- 송신자가 검출뿐만 아니라 비트 오류로부터 회복할 수 있도록 충분한 체크섬 비트들을 추가하는 것
- 송신자가 왜곡된 ACK 또는 NAK 패킷을 수신하면 현재 데이터 패킷을 단순히 다시 전송하는 것(마지막으로 전송된 ACK, NAK 패킷이 송신자에게 제대로 전달됐는지 알 수 없으므로 추가로 도착하는 패킷이 재전송된 패킷인지 새로운 패킷인지 알수가 없다.)

이러한 문제의 해결책(현재 사용하는은 데이터 패킷에 새로운 필드를 추가하고 이 필드 안에 순서번호(sequence number)를 삽입하는 방식으로 데이터 패킷에 송신자가 번호를 붙이는 것이다. 수신자가 수신된 패킷이 재전송인지를 파악할 때는 이 순서 번호만 확인하면 된다. 송신자는 응답된 ACK, NAK 패킷이 가장 최근에 보낸 데이터에 대한 응답인걸 알고 있으므로 ACK, NAK패킷에 순서번호를 적용할 필요는 없다.

![](https://i.ibb.co/smXYtQN/temp.png)
![](https://i.ibb.co/FggDQHS/temp.png)

위 그림은 rdt2.0의 수정 버전인 rdt2.1에 대한 FSM을 나타내고 있다. 전보다 2배 많은 상태를 가지고 있는데, 이는 패킷의 순서번호가 0 또는 1을 가져야 하는지를 반영해야 하기 때문이다. 순서 번호만 다를 뿐 동작은 같다.

수신자는 NAK 패킷을 송신하는 것 대신 이전 패킷에 대한 ACK을 다시 송신하는것으로 같은 효과를 볼 수 있다. 이를 위해 ACK 패킷에 순서번호가 포함되어야 한다. 이것이 rdt 2.2 모델이다.

#### 비트 오류와 손실 있는 채널상에서의 신뢰적인 데이터 전송: rdt3.0

패킷이 손상되는 것이 아니라 손실된다면 어떻게 처리해야 할까? 이를 인지했을 때에 해결 방법은 체크섬, 순서번호, ACK패킷, 재전송의 사용 등으로 이미 다루었지만 이를 인지하는 방법은 아직 다루지 않았다.

송신자가 전송한 패킷이 손실되거나 수신자가 전송한 ACK패킷이 손실되는 경우를 생각해보자. 송신자는 최소 송신자와 수신자 사이의 왕복 시간 지연(RTT)에 수신 측에서 패킷을 처리하는 데 필요한 시간만큼 기다린다. 그리고 시간이 되어도 응답이 없으면 패킷을 재전송 하는데, 중복 패킷으로 인해 생기는 문제점은 rdt2.2에서 해결을 이미 했으므로 문제없다. 이를 위해 일정 시간 후에 송신자를 인터럽트 할 수 있는 카운트다운 타이머가 필요하고 다음과 같이 동작한다.

1. 매 패킷이 송신된 시간에 타이머를 시작함
2. 타이머 인터럽트에 반응함(적당한 행동을 취함)
3. 타이머를 멈춤

![](https://i.ibb.co/4tsg0dD/temp.png)

위 그림은 패킷이 손상되거나 손실될 수 있는 채널에서 데이터를 신뢰적으로 전송하는 프로토콜인 rdt3.0에 대한 송신자 FSM을 보여준다. 프로토콜 rdt3.0은 패킷의 순서 번호가 0과 1이 번갈아 일어나므로 Alternating-bit protocol 이라고도 부른다.

![](https://i.ibb.co/MNXmcsj/Kakao-Talk-20230130-122010436.jpg)

### 4.2 파이프라이닝된 신뢰적인 데이터 전송 프로토콜

rdt3.0의 문제는 성능에 있다. stop-and-wait 방식을 사용하기 때문에 데이터 패킷을 보내고 응답을 기다리는 시간동안 마냥 대기하게 되는데 이러한 송신자 이용률을 개선하기 위해 연속적으로 데이터 패킷을 보내는 기술을 파이프라이닝이라고 부른다. 파이프라이닝 방식은 다음과 같은 중요성을 지니고 있다.

- 순서 번호의 범위가 커져야 한다.
- 프로토콜의 송신 측과 수신 측은 패킷 하나 이상을 버퍼링해야 한다.
- 필요한 순서 번호의 범위와 버퍼링 조건을 데이터 전송 프로토콜이 손실 패킷과 손상 패킷 그리고 상당히 지연된 패킷들에 대해 응답하는 방식에 달려있다. 파이프라인 오류 회복의 두 가지 기본적인 접근 방법으로 GBN(Go-Back-N, N부터 반복)과 SR(Selective Repeat, 선택적 반복)이 있다.

### 4.3 GBN

GBN 프로토콜에서 송신자는 확인 응답을 기다리지 않고 여러 패킷을 전송할 수 있다. 라이프라인에서 확인응답이 안 된 패킷의 최대 허용 수 N보다 크지 말아야 한다.

아래 그림은 GBN 프로토콜에서 송신자 관점의 순서 번호 범위를 보여준다. 확인응답이 안 된 가장 오래된 패킷의 순서 번호를 base로 정의하고 사용되지 않은 가장 작은 순서 번호를 nextseqnum으로 정의한다면, 순서번호의 범위에서 색별로 다른 4개의 간격을 식별할 수 있다.

![](https://i.ibb.co/xGyKdJj/temp.png)

GBN에서는 수신자의 행동도 단순하다. 순서 번호 n을 가진 패킷이 오류 없이 순서대로 수신된다면, 수신자는 패킷 n에 대한 ACK을 송신하고 상위게층에 패킷의 데이터 부분을 전달한다. 그 외의 경우에는 수신자는 그 패킷을 버리고 가장 최근에 제대로 수신된 순서의 패킷에 대한 ACK를 재전송한다.

GBN 프로토콜에서 수신자는 순서가 잘못된 패킷들을 버린다. 버퍼링 했다가 나중에 다시 전달할 수도 있지만 버린 패킷도 어차피 다시 재전송 되므로 상관없다. 물론 정확히 전송된 패킷이 다음에 또 정확히 전송되리라는 보장이 없어서 여러번의 재전송이 필요할 수도 있긴하다.

GBN 프로토콜은 TCP의 신뢰적인 데이터 전송의 거의 모든 기술이 통합되었다. 이 기술에는 순서 번호, 누적 확인응답, 체크섬, 타임아웃/재전송 동작에 대한 사용이 포함된다.

### 4.4 SR

GBN의 문제점은 재전송이 필요한 패킷이 생길때마다 다수의 패킷들이 추가적으로 재전송 되므로 불필요한 트래픽이 많이 발생한다는 것이다.

이를 위해 SR(Selective Repeat)은 오류가 발생한 패킷만을 재전송하므로 불필요한 재전송을 피한다 윈도 크기 N은 파이프라인에서 아직 확인응답이 안된 패킷 수를 제한하는데 사용된다. 그러나 GBN과는 달리 송신자는 윈도에 있는 몇몇 패킷에 대한 ACK를 이미 수신했을 것이다. 아래 그림은 순서 번호 공간에 대한 SR 송신자의 관점과 SR 송신자에 의한 다양한 행동들을 설명한다.

![](https://i.ibb.co/4S043xC/temp.png)

순서가 바뀐 패킷은 빠진 패킷이 수신될 때까지 버퍼에 저장하고, 빠진 패킷이 수신된 시점에서 일련의 패킷을 순서대로 상위 계층에 전달할 수 있다.

## 5. 연결 지향형 트랜스포트: TCP

### 5.1 TCP 연결

TCP 연결을 전이중 서비스(full-duplex service)를 제공한다. 또한 TCP 연결을 항상 단일 송신자와 단일 수신자 사이의 점대점(point-to-point)이다.

클라이언트 프로세스와 서버 프로세스의 3-way handshaking은 클라이언트가 먼저 특별한 세그먼트를 보내고 서버가 두번째 특별한 세그먼트로 응답한 후 마지막으로 클라이언트가 세번째 특별한 세그먼트로 다시 응답하면 연결된다.

![](https://i.ibb.co/ss9mqpV/temp.png)

TCP는 3-way handshake동안 송신 버퍼(send buffer)로 데이터를 보낸다. 때때로 TCP는 송신버퍼에서 데이터 묶음을 만들어서 네트워크로 보낸다. 세그먼트로 모아 담을 수 있는 최대 데이터 양은 최대 세그먼트 크기(maximum segment size, MSS)로 제한되며 MSS는 일반적으로 로컬 송신 호스트에 의해 전송될 수 있는 가장 큰 링크 계층 프레임의 길이(최대 전송 단위(maximum transmission unit, MTU))에 의해 일단 결정되고, 그런 후에 TCP 세그먼트와 TCP/IP 헤더 길이(통상 40바이트)가 단일 링크 계층 프레임에 딱 맞도록 하여 정해진다. 이더넷과 PPP 링크 계층 프로토콜은 모두 1,500바이트의 MTU를 갖는다. 따라서 MSS의 일반적인 값은 1460바이트다. MSS는 헤더를 포함하는 TCP 세그먼트의 최대 크기가 아니라, 세그먼트에 있는 애플리케이션 계층 데이터의 최대 크기이다.

TCP는 TCP 헤더와 클라이언트 데이터를 하나로 짝지어 TCP 세그먼트를 구성한다. 세그먼트는 네트워크 계층에 전달되며, 네트워크 계층 IP 데이터그램 안에 각각 캡슐화된다.

### TCP 세그먼트 구조

TCP세그먼트는 헤더 필드와 데이터 필드로 구성되어 있고, 데이터 필드는 MSS크기로 의해 분할되어 보내진다. TCP 헤더는 일반적으로 20바이트(UDP는 12바이트)이다.

아래 그림은 TCP 세그먼트의 구조를 보여주는데, 헤더에는 UDP와 마찬가지로 다중화와 역다중화를 하는데 필요한 출발지와 목적지 포트번호가 존재하고, 체크섬 필드 또한 존재한다. 그외에 다음과 같은 필드들도 포함한다.

![](https://i.ibb.co/xfn3cM0/temp.png)

- 32비트 순서 번호 필드(sequence number field)와 32비트 확인 응답 필드(acknowledgement number field)
- 16비트 수신 윈도(receive window) 필드는 흐름제어에 활용된다.
- 4비트 헤더 길이 필드(header length field)
- 선택적이고 가변적인 길이의 옵셜 필드(option field)는 송신자와 수신자가 MSS를 협상하거나 고속 네트워크에서 사용하기 위한 윈도 확장 요소로 이용된다.
- 플래그 필드(flag field)는 6비트를 포함한다. ACK, RST, SYN, FIN, PSH(수신자가 데이터를 상위 계층에 즉시 전달해야 함을 표시), URG(Urgent 긴급)

#### 순서 번호와 확인 응답 번호

순서 번호는 세그먼트에 대해서가 아니라 바이트 스트림의 순서라는 관점에서 분할된 데이터의 몇번째 바이트인지를 반영한다. 즉 MSS가 1000이고 500,000바이트의 파일을 전송한다고 하면 첫번째 순서 번호는 0이고 2번째는 1000 ... 이런식이다.

수신자가 세그먼트에 표시하는 확인 응답 번호는 송신자에게 기대하는 다음 바이트의 순서 번호다. 예를들어 수신 호스트가 0~535바이트를 포함하는 세그먼트를 수신했고 900~1000바이트를 포함하는 세그먼트를 수신했다고 하면, 다음번에 수신하기를 원하는 세그먼트의 순서 번호는 536이므로 응답 세그먼트의 확인 응답 번호는 536이다.

여기서 순서가 다르게 도착한 세그먼트가 있을 때, 버리는 방식과 버퍼에 저장했다가 순서가 보장됐을때 사용하는 방식이 있는데 현대에서는 주로 후자를 많이 사용한다.

### 5.3 왕복 시간(RTT) 예측과 타임아웃

#### 왕복 시간 예측

타임아웃은 위한 왕복시간을 어떻게 예측할 수 있을까? 전송이 성공적으로 완료된 세그먼트들의 RTT를 평균내서 구할 수 있다. 구해진 값에 새롭게 성공적으로 전송된 세그먼트의 RTT가 추가되면 가중치를 계산해 계속해서 갱신하는 방식이다. 보통은 기존 RTT에 7/8을 곱한 값에 새로운 RTT의 1/8을 곱해 더하는 방식으로 계산한다. 이러한 평균을 지수적 가중 이동 평균(exponential weighted moving average, EWMA)이라고 부른다.

#### 재전송 타임아웃 주기의 설정과 관리

그렇다면 RTT평균을 어떻게 활용해야 적절한 타임아웃 주기가 될까? RTT 평균에 DevRTT\*4를 더해 사용한다. DevRTT는 위에서 기존 RTT와 새로운 RTT의 값 차이에 상수를 추가해 계산한 값이다.

### 5.4 신뢰적인 데이터 전송

TCP가 어떻게 신뢰적인 데이터 전송을 제공하는지 호스트 A에서 호스트 B로 데이터가 오직 한 방향으로만 보내지며, 호스트 A가 큰 파일을 전송하는 것으로 가정해보자.

TCP 송신자의 데이터 전송/재전송에 관련된 세 가지 주요 이벤트가 있음을 볼 수 있는데, 그것은 상위 애플리케이션으로부터 수신된 데이터, 타이머 타임아웃, ACK 수신이다. 첫번째 주요 이벤트 발생으로, TCP는 애플리케이션으로부터 데이터를 받고, 세그먼트로 이 데이터를 캡슐화하고,IP에게 이 세그먼트를 넘긴다. 타이머가 이미 다른 세그먼트에 대해 실행중이 아니면, TCP는 이 세그먼트를 IP로 넘길 때 타이머를 시작한다. 타이머의 만료주기는 이전에 설명했듯이 EstimatedRTT와 DevRTT로 계산할 수 있다.

두번째 주요 이벤트는 타임아웃이다. TCP는 타임아웃 이벤트에 대해 타임아웃을 일으킨 세그먼트를 재전송하며 응답한다. 그리고 TCP의 타이머를 다시 시작한다.

세번째 주요 이벤트는 수신자로부터의 수신 확인 응답 세그먼트(ACK) 수신이다. 이 이벤트가 일어나면, TCP는 변수 SendBase과 ACK 값 y를 비교한다. SendBase는 수신 확인응답이 되지 않은 가장 오래된 바이트의 순서 번호다. TCP는 누적 확인응답을 사용하고 y는 y바이트 이전의 모든 바이트의 수신을 확인한다. y > SendBase이면 ACK는 이전에 확인 응답 안 된 하나 이상의 세그먼트들을 확인해준다. 따라서 송신자는 자신의 SendBase 변수를 갱신한다. 또한 아직 확인 응답이 안 된 세그먼트들이 존재한다면 타이머를 다시 시작한다.

#### 몇가지 흥미로운 시나리오

![](https://i.ibb.co/WFH57kk/temp.png)
![](https://i.ibb.co/FzLpHvQ/temp.png)
![](https://i.ibb.co/B2C3ygM/temp.png)

#### 타임아웃 주기의 두배로 설정

혼잡제어를 위해서 타이머가 만료될 때마다 타임아웃 주기를 2배로 늘려가는 방법이 있다. 네트워크가 혼잡한 상황인데도 계속해서 일정 주기로 패킷을 재전송한다면 혼잡을 악화시킬 수 있다.

#### 빠른 재전송

연속적으로 패킷을 보낼 때, 중간에 손실된 패킷이 존재하면 수신자는 해당 패킷의 순서번호를 확인 응답 번호로 하는 ACK 패킷을 보낸다. 손실된 패킷 이후의 패킷들이 연속적으로 수신측에 도착하게 되면 그 수만큼 중복 ACK패킷을 보내게 되는데 이런 중복 ACK 패킷을 3개 이상 받으면 송신측에서는 타임아웃을 기다리지 않고 즉시 해당 패킷을 재전송하는 빠른 재전송을 한다.

#### GBN인가 SR인가?

TCP는 GBN과 SR의 혼합 형태이다. 기본적으로는 GBN과 같지만 TCP는 확인이 되지 않은 패킷이 발견되었을 때 해당 패킷부터 순차적으로 모두 다시 전송하는게 아니라 해당 패킷만을 재전송 한다는 점에서 SR과 비슷하다. TCP에 수정제안된 선택적 확인응답은 TCP 수신자가 마지막으로 올바로 수신된 '순서가 맞는' 세그먼트에 대해 누적 확인응답을 하기보다는 '순서가 틀린' 세그먼트에 대해 선택적으로 확인응답을 한다.

### 5.5 흐름 제어

흐름 제어와 혼잡 제어는 둘 다 송신자의 패킷 전송을 억제하는 방식으로 작동한다는 점에서는 유사하지만 발생 원인이 다르다. 혼잡 제어의 경우는 네트워크가 혼잡해 데이터 전송이 지연될 때 발생하지만 흐름 제어는 수신자의 수신버퍼가 가득 차 오버플로가 일어날 때 발생한다. 이에 수신자는 수신버퍼가 가득찼다는 신호를 송신측에 보내고 송신측은 패킷 전송을 중지한다. 수신버퍼에 여유가 생겨도 송신측에 알 수 없는 문제가 발생할 수 있는데 이를 위해 송신측에서 지속적으로 1바이트 데이터를 전송해 수신버퍼의 상태를 확인하게 된다.

### 5.6 TCP 연결 관리

3way handshake는 다음과 같은 진행과정을 따른다.

1. 클라이언트 측 TCP는 애플리케이션 데이터가 존재하지 않지만 헤더의 SYN비트를 1로 설정하고 최초의 순서번호를 임의로 선택한 패킷을 서버 TCP로 보낸다. 이는 IP 데이터그램 안에서 캡슐화되고 서버로 송신된다.
2. TCP SYN 세그먼트를 포함하는 IP 데이터그램이 서버에 도착하면 서버는 역캡슐화해 SYN 비트를 확인한다. 그리고 연결에 TCP 버퍼와 변수를 할당하고 클라이언트로 연결승인 세그먼트를 송신한다. 이 세그먼트도 또한 데이터를 포함하지 않는다. 이때 헤더에는 1로 설정된 SYN 비트와 클라이언트의 순서번호 + 1로 설정된 확인 응답 필드, 그리고 서버가 자신의 최초 순서번호를 선택한 순서번호 필드가 들어있다. 이 세그먼트는 SYNACK 세그먼트라고 불린다.
3. SYNACK 세그먼트를 수신한 클라이언트는 연결에 버퍼와 변수를 할당하고 헤더에 서버의 순서번호 필드 + 1을 확인 응답 필드안에 넣고 SYN 패킷은 0으로 설정해 다시 보낸다.

![](https://i.ibb.co/M2PqN1x/temp.png)
![](https://i.ibb.co/TbX9n10/temp.png)

## 6. 혼잡 제어의 원리

### 6.1 혼잡의 원인과 비용

#### 시나리오 1: 2개의 송신자와 무한 버퍼를 갖는 하나의 라우터

라우터의 처리속도에는 한계가 있으므로 처리속도를 넘어서는 전송률로 데이터를 보내게 되면 지연되게 되고 결국에는 무한히 지연되게 된다.

#### 시나리오 2: 2개의 송신자, 유한 버퍼를 가진 하나의 라우터

버퍼가 유한하고 연결은 신뢰적이라고 가정한다.

첫째로, 호스트 A가 어떻게 해서든 라우터에 있는 버퍼가 비어 있는지 그렇지 않은지를 알 수 있고, 버퍼가 비어 있을 때만 패킷을 송신할 수 있는 비현실적인 경우를 고려해보자. 이러한 경우에 성능은 이상적이다.
둘째로, 패킷이 확실히 손실된 것을 알았을 때만 송신자가 재전송하는 좀 더 현실적인 경우를 생각해보자. 여기서 혼잡 네트워크의 또 다른 비용을 알 수 있다. 즉, 송신자는 버퍼 오버플로 때문에 버려진 패킷을 보상하기 위해 재전송을 수행해야 한다.
셋째로, 송신자에서 너무 일찍 타임아웃되어 패킷이 손실되지 않았지만 큐에서 지연되고 있는 패킷을 재전송하는 경우를 생각해보자. 이럴 때 원래의 데이터 패킷과 재전송 패킷 둘 다 수신자에게 도착한다. 중복 전송된 패킷은 버려지므로 낭비이다. 여기에 혼잡 네트워크의 또 다른 비용이 있다. 즉, 커다란 지연으로 인한 송신자의 불필요한 재전송은 라우터가 패킷의 불필요한 복사본들을 전송하는데 링크 대역폭을 사용하는 원인이 된다.

#### 시나리오 3: 4개의 송신자와 유한 버퍼를 갖는 라우터, 그리고 멀티홉 경로

마지막 혼잡 시나리오에서 4개의 호스트는 겹쳐지는 2홉 경로를 통해 패킷을 전송한다. 다시 각각의 호스트가 안정적인 데이터 전송 서비스를 실행하기 위해 타임아웃/재전송 메커니즘을 사용한다고 가정한다.

![](https://i.ibb.co/chTvT87/temp.png)

B-D의 부하가 무한대가 되면 A-C 연결의 처리량은 0으로 수렴한다. 여기서 혼잡 때문에 패킷을 버려야 하는 또 다른 비용을 확인할 수 있다. 패킷이 경로상에서 버려질 때, 버려지는 지점까지의 패킷을 전송하는데 사용된 상위 라우터에서 사용된 전송 용량은 낭비된 것이다.

### 6.2 혼잡 제어에 대한 접근법

- 종단 간의 혼잡 제어 : 혼잡 제어에 대한 종단 간의 접근 방식에서 네트워크 계층은 혼잡 제어 목적을 위해 트랜스포트 계층에게 어떤 직접적인 지원도 제공하지 않는다. TCP는 단지 세스먼트 손실을 혼잡 발생 표시로 간주하고 윈도 크기를 줄인다.

- 네트워크 지원 혼잡 제어 : 네트워크 지원 혼잡 제어에서 라우터들은 네트워크 안에서 혼잡 상태와 관련하여 송신자나 수신자 또는 모두에게 직접적인 피드백을 제공한다. 알림의 첫번째 방법은 라우터에서 초크 패킷을 송신자에게 보내는 것이고, 두번째 방법은 송신자에서 수신자에게로 흐르는 패킷안의 특정 필드에 표시하는 것이다. 후자의 경우는 수신자가 해당 패킷을 수신하고 혼잡 상태를 송신자에게 알려야하므로 RTT의 시간이 소요된다.

## 7. TCP 혼잡 제어

### 7.1 전통적인 TCP의 혼잡 제어

TCP가 전송 트래픽을 어떻게 조절하는가?

-> 혼잡 윈도를 사용해 TCP 송신자가 네트워크로 트래픽을 전송할 수 있는 속도에 제약을 가한다.

TCP는 혼잡을 어떻게 감지하는가?
-> 타임아웃 또는 수신자로부터 중복된 3개의 ACK 수신이 발생하면 손실 이벤트가 발생했다고 하고 혼잡으로 파악한다.

TCP는 혼잡을 감지함에 따라 송신률을 제한하기 위해 어떤 알고리즘을 사용해야 하는가?
-> 다음과 같은 처리 원칙들에 따른다.

- 손실된 세그먼트는 혼잡을 의미하여, 이에 따라 TCP 전송률은 한 세그먼트를 손실했을 때 줄여야 한다.
- 확인응답된 세그먼트는 네트워크가 송신자의 세그먼트를 수신자에게 전송했다는 것이고, 이에 따라 이전에 확인 응답되지 ㅇ낳은 세그먼트에 대해 ACK가 도착하면 송신자의 전송률은 증가할 수 있다.
- 대역폭 탐색

TCP 혼잡 제어 알고리즘은 다음과 같은 중요한 3가지 구성요소를 갖는다.

1. 슬로 스타트(slow start)
2. 혼잡 회피(congestion aviodance)
3. 빠른 회복(fast recovery)

#### 슬로 스타트

TCP 연결이 시작될 때 혼잡 윈도(cwnd)의 값은 일반적으로 1 MSS로 초기화된다. 이후 전송 세그먼트가 첫 번째로 확인 응답을 받을 때마다 1 MSS씩 증가한다. 이런식으로 TCP 전송률은 작은 값으로 시작하지만 지수적으로 증가하게 된다. 이 슬로 스타트는 타임아웃으로 표시되는 손실 이벤트가 있을 경우 새로운 슬로 스타트를 시작하고, cwnd 값이 ssthresh와 같은 경우 혼잡 회피 모드로 전환하며 3개의 중복 ACK가 검출되며 빠른 회복 상태로 들어간다.

#### 혼잡 회피

혼잡 회피로 들어가는 시점에서 cwnd는 혼잡이 발견됐을 때의 값의 절반이 된다. 이후로는 전처럼 2배씩 늘려가기 보다는 RTT 마다 1 MSS 만큼의 cwnd의 값을 증가시킨다. 3개의 중복된 ACK 이벤트에 의해 발생하는 경우는 cwnd의 값을 반으로 줄이고 ssthresh의 값을 cwnd의 반으로 기록하고 빠른 회복 상태로 들어간다.

#### 빠른 회복

빠른 회복에서는 cwnd 값을 손실된 세그먼트에 대해 수신된 모든 중복된 ACK에 대해 1 MSS만큼씩 증가시킨다. 손실된 세그먼트에 대한 ACK가 도착하면 TCP는 cwnd 혼잡 회피 상태로 들어간다. 만약 타임아웃 이벤트가 발생한다면 빠른 회복은 슬로 스타트 및 혼잡 회피에서와 같은 동작을 수행한 후 슬로 스타트로 전이한다.

#### TCP 혼잡 제어: 복습

손실이 타임아웃이 아니라 3개의 중복 ACK로 표시된다고 가정하면, TCP의 혼잡 제어는 RTT 마다 1 MSS씩 cwnd의 선형 증가와 3개의 중복 ACK 이벤트에서 cwnd의 절반화로 구성된다. 이러한 이유로 TCP 혼잡 제어는 AIMD 혼잡 제어 형식이라고 불린다.

![](https://i.ibb.co/HtQ4dYb/temp.png)

### 7.2 네트워크 지원 명시적 혼잡 알림과 지연 기반 혼잡 제어

#### 명시적 혼잡 알림(ECN)

라우터는 IP 데이터그램의 헤더에 있는 ECN 비트를 사용해 수신자에게 네트워크 혼잡 상태를 알릴 수 있다. 수신자는 이를 통해 혼잡상태를 파악하고 세그먼트의 ECE비트를 설정해 송신자에게 혼잡 상태를 알리고 그러면 송신자는 혼잡 상태에 대응하고 다음에 전송되는 TCP 수신자 세그먼트 헤더에 CWR 비트를 1로 설정한다.

#### 지연 기반 혼잡 제어

TCP 베가스는 RTT를 측정해 일정값 이하로 내려가면 혼잡상태로 감지하고 속도를 제어하는 방식을 취한다.

### 7.3 공평성

특정 시점에서 TCP 연결들이 서로 다른 송신률을 가지더라도 결국 공평한 값으로 수렴한다.

![](https://i.ibb.co/bzQtGRv/temp.png)

UDP의 경우에는 혼잡 제어의 간섭을 받지 않으므로 불공평 하다고 느낄수도 있다. 하지만 UDP에 혼잡 제어를 적용하게 되어도 TCP는 병렬 처리가 가능하므로 또한 공평하지 않게 된다.

## 8. 트랜스포트 계층 기능의 발전

#### QUIC(Quick UDP Internet Connections): 빠른 UDP 인터넷 연결

보안 HTTP를 위한 트랜스포트 계층 서비스의 성능을 향상하기 위해 처음부터 새롭게 설계된 애플리케이션 계층 프로토콜이다. QUIC은 UDP를 하위 트랜스포트 계층 프로토콜로 사용하는 애플리케이션 계층 프로토콜이며, 특히 간순하지만 발전된 HTTP/2 버전 위에서 인터페이스되도록 설계되었다. 가까운 장래에 HTTP/3은 기본적으로 QUIC을 통합할 것이다. QUIC의 주요기능은 다음과 같다.

- 연결 지향적이고 안전함 : TCP와 마찬가지로 QUIC은 두 Host 간의 연결지향 프로토콜이다. 모든 QUIC 패킷은 암호화되며 연결 상태를 설정하는데 필요한 핸드셰이크와 인증 및 암호화에 필요한 핸드셰이크를 경합하여 먼저 TCP 연결을 설정한 다음 TCP 연결을 통해 TLS 연결을 설정하여 여러 RTT가 필요한 기존 프로토콜보다 더 빠른 설정을 제공한다.
- 스트림 : 단일 QUIC 연결을 통해 여러 애플리케이션 레벨의 '스트림'들을 다중화할 수 있으며 QUIC 연결이 설정되면 새 스트림을 빠르게 추가할 수 있다.
- 신뢰적이고 TCP 친화적인 혼잡 제어 데이터 전송 : 각 QUIC 스트림에 대해 독릭접으로 신뢰적인 데이터 전송을 제공한다. QUIC은 스트림별로 신뢰적이고 순서대로 전달하기 때문에 손실된 UDP 세그먼트는 해당 세그먼트에서 데이터가 전달된 스트림에만 영향을 준다. 다른 스트림의 HTTP 메세지는 계속 수신되어 애플리케이션에 전달될 수 있다.

끝으로, QUIC은 두 Host 사이에 신뢰적이고 혼잡 제어된 데이터 전송을 제공하는 애플리케이션 계층 프로토콜이라는 점을 다시 강조한다.

---

질문거리

- 멀티플렉싱과 디멀티플렉싱에 대해 설명해주세요
- TCP와 UDP의 차이에 대해서 설명해주세요
- HTTP가 TCP를 사용하는 이유는 뭔가요?
- TCP 세그먼트와 UDP 세그먼트는 어떻게 다른가요?
- 체크섬이 뭐고, 어떤식으로 활용되는지 설명해주세요
- 일반적인 TCP에서 데이터 전송은 어떤식으로 이루어 지는지 설명해주세요
- TCP 연결에서 타임아웃 시간은 어떻게 설정되나요?
- 3 way handshake와 4 way handshake에 대해서 설명해주세요
- ACK, SYN 같은 정보는 어떻게 전달하나요?
- SYN Flooding에 대해서 설명해주세요
- 4 way handshake가 목적인지 어떻게 파악할 수 있을까요?
- TCP는 네트워크의 혼잡 상태를 어떻게 알 수 있나요?
- TCP는 혼잡제어를 어떤식으로 수행하나요?
- 라우터가 네트워크의 혼잡 상태를 알리는 방법에 대해서 설명해주세요

트랜스포트 레이어의 전반적인 역할?
UDP가 왜 더 빠른지?
TCP 연결수가 많아지면 어떻게 처리하는게 좋을지? 소켓풀에 미리 소켓을 만들어두고 필요할 때 사용한다, keep-alive를 통해 연결을 유지함으로써 재연결에 필요한 자원을 줄인다. 4 way가 이루어질때는 소켓 파라미터를 초기화하고 다시 소켓풀에 넣는다(?) 소켓을 여는건 커널이 담당한다.
연결형 다중화, 역다중화와 비연결형 다중화, 역다중화의 차이?

synflood를 막는방법? tcp 연결을 막지 막지말고 앞단에서 ip를 확인하는 등의 조치를 취하는 방법으로 하면 된다.

www.google.을 쳤을때? -> UDP와 TCP를 동시에 사용하므로 이 걸 자세히 얘기해주면 좋을 것 같다

스레드가 소켓을 포함하는 구조인지, 아니면 

syns는 시간, 순서를 맞추는 개념
block은 lock을 거는 개념